<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>dokucool :D</title>
    <link rel="apple-touch-icon" sizes="180x180" href="./apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="./favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="./favicon-16x16.png">
    <meta name="apple-mobile-web-app-title" content="meteocool">
    <meta name="application-name" content="meteocool">
    <meta name="theme-color" content="#ffffff">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <link rel="apple-touch-startup-image" href="./apple-launch.png">

  </head>
  <body>
    <div id="map" style="position: absolute; top: 0; left: 0; height: 57px; width: 100%; z-index: 0;"></div>
    <nav id="navbar" class="navbar navbar-expand-lg navbar-light" style="position: absolute; top: 0; left: 0; width: 100%; z-index: 100000;">
      <div id="clockbg"></div>
      <div id="spacer"></div>
      <div id="compositBar">
        <div id="logolink">
          <a class="navbar-brand mr-auto mt-2 mt-lg-0" href="/">
            <img src="./android-chrome-512x512.png" width="30" height="30" class="d-inline-block align-top" alt="meteocool logo">
          </a>
        </div>
        <div id="logotext" style="padding-top: 6px; padding-left: 14px;"><div class="logoglow">meteocool</div></div></div>
      <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>
      <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <ul class="navbar-nav ml-auto"> <li class="nav-item bg-light" style="height: 100%; "><a id="documentationLink" class="nav-link" href="/">&laquo; map view</a></li> </ul>
      </div>
    </nav>
    <div id="body">
      <div class="warning">
        <div class="deflag"></div>
        <div>
          <h4>Documentation</h4>
          <p>The meteocool documentation is currently only available in German! Sorry.</p>
          <p>You can help by <a href="https://github.com/v4lli/meteocool/blob/master/frontend/src/documentation.html" target="_blank">translating it on Github</a>.</p>
        </div>
      </div>
   <h3 class="sectionHead"><span class="titlemark">1   </span> <a 
 id="x1-50002"></a>Anwendungsfälle</h3>
   <h4 class="subsectionHead"><span class="titlemark">1.1   </span> <a 
 id="x1-20001.1"></a>Regen-Radar</h4>
<!--l. 5--><p class="noindent" >Die zentrale Funktionalität von meteocool besteht in der Visualisierung von
wetterbezogenen Daten. Dabei liegt der Fokus auf mobilen Endgeräten und einer
darauf optimierten Oberﬂäche. Insbesondere soll die Anwendung asynchron
eintreﬀende Daten (Radardaten, Blitze, andere Ereignisse) ohne ein &#x0022;neuladen&#x0022;der
Seite anzeigen.
</p><!--l. 12--><p class="noindent" >
</p>
   <h4 class="subsectionHead"><span class="titlemark">1.2   </span> <a 
 id="x1-30001.2"></a>Vorab-Benachrichtigungen</h4>
<!--l. 14--><p class="noindent" >Die bei der Verarbeitung der Wetterdaten anfallenden Artefakte können genutzt
werden, um relativ genaue, kurzfristige und lokale Benachrichtigungen über
Wetterumschwünge an mobile Endgeräte zuzustellen.
</p><!--l. 19--><p class="indent" >   Besonders bei sich kurzfristig entwickelnden Tiefdrucklagen (Sommergewittern)
können derartige Informationen nicht dem normalen Wetterbericht entnommen
werden.
</p><!--l. 23--><p class="noindent" >
</p>
   <h4 class="subsectionHead"><span class="titlemark">1.3   </span> <a 
 id="x1-40001.3"></a>Crowd Sourced Meteorology</h4>
<!--l. 25--><p class="noindent" >Zu Zwecken der Forschung zeichnet die meteocool iOS-App barometrische Daten
auf mobilen Endgeräten auf. Es ist zu evaluieren, ob diese Daten in einer
weiterverarbeiteten Form einen meteorologischen Wert besitzen und eventuell dazu
genutzt werden koennen, Wetterumschwünge schneller und mit verbesserter örtlicher
und zeitlicher Genauigkeit vorherzusagen.
</p>
   <h3 class="sectionHead"><span class="titlemark">2   </span> <a 
 id="x1-50002"></a>Architektur</h3>

   <div class="wrapfig-l"><a id="x1-60011"></a><img src="radarverbund.jpg" />
<br />  <div class="caption" 
><span class="id">Abbildung 1:  </span><span  
class="content">DWD  Radarverbund  mit
Abdeckung. Bildquelle: &copy; <a href="http://dwd.de">DWD</a></span></div><!--tex4ht:label?: x1-60011 -->                                          </div>

<!--l. 3--><p class="noindent" >Die Verarbeitung und Speicherung von Wetter- und Nutzerdaten aus asynchronen
Quellen bedarf einer Kombination aus verschiedenen Diensten und Softwaresystemen.
Die Umsetzung erfolgt daher in Form von <span 
class="ecti-1000">Microservices</span>. Diese erleichtern den
administrativen Umgang gegenüber monolithischen Systemen stark. Ebenfalls können

so z.B. Anforderungen an die Verfügbarkeit leichter umgesetzt werden (siehe
<span 
class="ecbx-1000">??</span>).
</p><!--l. 13--><p class="indent" >   Im Vordergrund steht die Verarbeitung von Radardaten. Auf den daraus
resultierenden Artefakten basieren die meisten Funktionen der Plattform.
</p><!--l. 17--><p class="noindent" >
</p>
   <h4 class="subsectionHead"><span class="titlemark">2.1   </span> <a 
 id="x1-60002.1"></a>Verarbeitung von Radardaten</h4>


<!--l. 25--><p class="noindent" >Die Radardaten werden ca. alle 5 Minuten durch den Deutschen Wetterdienst zur
Verfügung gestellt und besitzen eine räumliche Auﬂösung von 1x1 km pro Pixel.
<span class="cite">[<span 
class="ecbx-1000">?</span>]</span>
</p><!--l. 29--><p class="indent" >   meteocool verarbeitet bereits die sogenannte <span 
class="ectt-1000">composite</span>-Variante der Radardaten.
In dieser vorverarbeiteten Version wurden bereits die Aufnahmen aller Stationen im
Radarverbund zu einem nationalen Gitter kombiniert. Im vom DWD für diesen
Zweck deﬁnierten Run-Length-Encoding-Verfahren sind für diesen Wert 8 Bit pro
Pixel vorgesehen. <span class="cite">[<span 
class="ecbx-1000">?</span>]</span>
</p><!--l. 36--><p class="indent" >   Die Regen-Intensitäten liegen pro Pixel in einer eigens vom DWD deﬁnierten
Einheit “<span 
class="ecti-1000">RVP6</span>” vor. Vor der Weiterverarbeitung werden die Werte in die
gebräuchlichere Einheit dbZ (Dämpfung relativ zum Faktor Z; logarithmische Skala,
dimensionslos <span class="cite">[<span 
class="ecbx-1000">?</span>]</span>).
</p><!--l. 43--><p class="indent" >   Die Radardaten werden automatisch vom DWD Opendata FTP Server abgeholt
und mit dem abhängigkeitsbasierten Build-System <span 
class="ecbx-1000">GNU Make </span>und diversen
Python-Skripten durch die im Folgenden beschriebenen Verarbeitungsschritte
transformiert.
</p><!--l. 48--><p class="noindent" >
</p>
   <h5 class="subsubsectionHead"><span class="titlemark">2.1.1   </span> <a 
 id="x1-70002.1.1"></a>Visualisierung</h5>

<!--l. 72--><p class="noindent" >
<div class="wrapfig-r">
<img src="legend_big.png" alt="Legend" class="inline_legend"/>
<br /> </p><div class="caption"><span class="id">Abbildung 2: </span><span  
       class="content">Aus Grundfarben generierte Legende</span></div><!--tex4ht:label?: x1-70022 --> </div>

<!--l. 51--><p class="noindent" >Um die Radardaten auf einer zwei-dimensionalen Karte verständlich darzustellen,
müssen die Daten im Sinne einer dritten Dimension visualisiert werden. Dazu wurde
zunächst ein einfaches Verfahren gewählt, welches die Intensitäten zwischen 0 dbZ
(Annahme: kein Regen) und 65 dbZ (extremer Starkregen/Hagel) farblich
kodiert.
</p><!--l. 57--><p class="indent" >   Um bei einer zukünftigen Erhöhung der derzeit 256 Intensitäts-Stufen ﬂexibel
reagieren zu können, wurde, anstatt einer statischen Palette, ein linearer Farbverlauf
innerhalb jeder der acht Farbstufen der Skala implementiert:

</p><!--l. 62--><p class="indent" >   Die Grundfarben <span class="footnote-mark"><a 
href="html2.html#fn1x0"><sup class="textsuperscript">1</sup></a></span><a 
 id="x1-7001f1"></a>
werden im RGB-Farbformat angegeben. Ein Python-Script konvertiert diese ins
HSL-Farbmodell und schwächt die L-Komponente (<span 
class="ecti-1000">Lightness</span>) nach rechts hin
ab.
</p><!--l. 67--><p class="indent" >   Dem Betrachter soll der dunklere Farbton eine höhere Sturmintensität
signalisieren.
</p>

   <h5 class="subsubsectionHead"><span class="titlemark">2.1.2   </span> <a 
 id="x1-80002.1.2"></a>Geo-Referencing</h5>
   <div class="wrapfig-r" style="width: 25%;"><a id="x1-80013"></a><img 
src="reflectivity_raw.png" alt="PIC"  
 />
<br /> <div class="caption" 
><span class="id">Abbildung 3: </span><span  class="content">Radardaten nach
Einfärbung,         vor         der
Georeferenzierung</span></div><!--tex4ht:label?: x1-80013 -->                  </div>
<!--l. 87--><p class="noindent" >Das Radarkomposit liegt nun als mehrkanaliges Rasterbild (<a 
href="#x1-80013">3<!--tex4ht:ref: fig:reflectivity_raw --></a>) in der vom DWD
vorgegebenen Auﬂösung von 1100x900 km (= Pixel) vor. Das Radarbild
muss nun in eine einheitliche Projektion überführt werden, so dass es ohne
Verzerrungen über vorhandenes Kartenmaterial gelegt werden kann. Da das
Kartenmaterial von OpenStreetMap in der <span 
class="ecbx-1000">Web Mercator Projektion </span><span class="cite">[<span 
class="ecbx-1000">?</span>]</span>
vorliegt, sollen die Radardaten ebenfalls in diese Projektion umgewandelt
werden.
</p><!--l. 96--><p class="indent" >   Nachdem die Projektion mit einem Tool aus der GDAL-Bibliothek zu <span 
class="ecti-1000">Web</span>
<span 
class="ecti-1000">Mercator </span>geändert wurde, muss das resultierende Bild zudem noch an einem
Referenzpunkt in einem globalen Koordinatensystem angehängt werden.
Besagte Eckpunkte liefert der DWD in seiner oﬃziellen Dokumentation.
<span class="cite">[<span 
class="ecbx-1000">?</span>]</span>
</p><!--l. 104--><p class="indent" >   Zur ﬂexiblen, endgeräteunabhängigen Auslieferung der Bilddaten werden die
Radardaten schließlich in das Container-Format <span 
class="ectt-1000">.mbtiles </span>verpackt, welche eine
Aufteilung der Radardaten in einzelne Kacheln in verschiedenen Auﬂösungen
(<span 
class="ecti-1000">Zoom-Stufen</span>) vorsieht. <span class="cite">[<span 
class="ecbx-1000">?</span>]</span>
</p><!--l. 110--><p class="noindent" >
</p>
   <h5 class="subsubsectionHead"><span class="titlemark">2.1.3   </span> <a 
 id="x1-90002.1.3"></a>Nowcast-Daten</h5>
<!--l. 113--><p class="noindent" >Neben den aktuellen Radardaten stellt der DWD auch alle 5 Minuten einen
sogenannten <span 
class="ecti-1000">Nowcast </span>bereit. Dabei handelt es sich um zeitlich interpolierte
Satellitenbilder (im gleichen Format wie im vorherigen Schritt behandelte “live”
Radarbild). <span 
class="ecti-1000">Nowcast</span>-Vorhersagen sind zeitlich meist auf wenige Stunden begrenzt,
besitzen allerdings eine wesentlich höhere Genauigkeit als globale Wettermodelle, die
(aufgrund ihrer Komplexität) nur alle 3-12 Stunden neu berechnet werden.
<span class="cite">[<span 
class="ecbx-1000">?</span>]</span>
</p><!--l. 122--><p class="indent" >   Die Integration dieser Vorhersage ermöglicht dem Benutzer der App die
Bestimmung von Zugrichtung und Abregenverhalten von Regenwolken und
Gewittern. Sie basieren auf Windrichtung, Luftdruck und anderen lokalen
Messungen, welche örtlich vom DWD vorgenommen und verarbeitet werden.
</p><!--l. 128--><p class="indent" >   Die Vorhersagen liegen in einem kleineren Gitter von 900x900 km in 24 Dateien
vor (d.h. bis zu 120 Minuten akkurater Vorhersagen). Die Verarbeitung verläuft
analog zu den in <a 
href="#x1-80002.1.2">2.1.2<!--tex4ht:ref: georef --></a> erläuterten Radardaten.

</p><!--l. 133--><p class="noindent" >
</p>
   <h4 class="subsectionHead"><span class="titlemark">2.2   </span> <a 
 id="x1-100002.2"></a>Vorab-Benachrichtigungen</h4>
<!--l. 135--><p class="noindent" >Aufgrund eines Nutzerwunsches wurden relativ früh im Entwicklungsprozess sog.
Push-Benachrichtigungen (siehe Punkt <a 
href="#x1-200003">3<!--tex4ht:ref: ios --></a>) implementiert.
</p><!--l. 139--><p class="indent" >   Die zugrundeliegende Idee ist, dass die mobile Anwendung im Hintergrund eine
grobe, aktuelle Position des jeweiligen Nutzers anonym an den meteocool-Server
übermittelt. Bei der darauﬀolgenden, regelmäßigen Verarbeitung neuer Nowcast-Daten
(wie in <a 
href="#x1-90002.1.3">2.1.3<!--tex4ht:ref: nowcast --></a> beschrieben), werden die Vorhersagen anhand der zuvor übermittelten
Positionen auf Regen überprüft.
</p>
   <hr /><div class="figure" 
>

<a 
 id="x1-100014"></a>

<!--l. 148--><p class="noindent" ><img 
src="meteocool_notify_2x.png" alt="PIC"  
 />
<br /> </p><div class="caption" 
><span class="id">Abbildung 4: </span><span  
class="content">Kontrollﬂuss bei der Zustellung von Push-Benachrichtigungen</span></div><!--tex4ht:label?: x1-100014 -->

   </div><hr class="endfigure" />
<!--l. 153--><p class="indent" >   Technisch betrachtet lässt sich das 900x900 km Gitter als dreidimensionales Array
betrachten. Um die vorhergesagte Intensität an einer GPS-Koordinate bestimmen zu
können, müssen die GPS-Koordinaten vom Latitude/Longitude-Format (WSG84) in
ein <span 
class="ectt-1000">x</span>- und <span 
class="ectt-1000">y</span>-Index umgerechnet werden. Danach kann der Zugriﬀ auf die dritte
Dimension (Regenintensität) erfolgen.
</p><!--l. 160--><p class="indent" >   Verschiedene Parameter der Benachrichtung sind per REST-API konﬁgurierbar.
Dazu gehören unter anderen:
</p>
     <ul class="itemize1">
     <li class="itemize">GPS-Koordinaten des zu überwachenden Ortes
     </li>
     <li class="itemize">Horizontale Genauigkeit des Standorts
     </li>
     <li class="itemize">Zeitintervall  der  Vorabbenachrichtigung  (5  bis  120  Minuten;  kleinere
     Werte bedeuten weniger <span 
class="ecti-1000">false positives</span>)
     </li>
     <li class="itemize">Intensität,  ab  der  eine  Benachrichtigung  gewünscht  ist  (Nieselregen,
     Regen, Starkregen, Hagel, ...)</li></ul>
<!--l. 176--><p class="indent" >   Neben den über die API konﬁgurierbaren Parametern nimmt der Server diverse
Optimierungen bezüglich des Benachrichtigungsverhaltens vor. Der Hintergrund
dabei ist, dass Smartphone-Benutzer Apps mit übermäßig vielen (irrelevanten)
Push-Benachrichtigungen schnell wieder de-installieren. In einer Beta-Testphase
wurden folgende Probleme identiﬁziert:
     </p><ol  class="enumerate1" >
     <li 
              class="enumerate" id="x1-10003x1"><p>Wenn der Benutzer sich schnell durch eine Regenfront bewegt (z.B. Auto
     oder  Zug)  meldet  sein  Smartphone  des  Öfteren  einen  neuen  Standort
     (Punkt  auf  der  Strecke),  für  den  der  Nutzer  einige  Minuten  später
     benachrichtigt wird.</p>
     <!--l. 190-->Dies kann ggf. dazu führen, dass sich eine Menge an Benachrichtungen
     auf dem Bildschirm des Smartphones ansammeln, die für den reisenden
     Nutzer nicht relevant sind.
     <!--l. 195--><p class="noindent" ><span 
class="cmsy-10">⇒ </span>Punkt <a 
href="#x1-110002.2.1">2.2.1<!--tex4ht:ref: travel --></a>
     </p></li>
     <li 
  class="enumerate" id="x1-10005x2">Bei kurzen Schauern kann es sein, dass der Nutzer nichts vom Gewitter
     mitbekommt,  z.B.  weil  er  sich  in  einem  Gebäude  aufhält  (vor  allem
     nachts). In diesem Fall interessieren ihn die Benachrichtungen nicht, wenn
     es bereits wieder aufgehört hat zu regnen.
     <!--l. 202--><p class="noindent" ><span 
class="cmsy-10">⇒ </span>Punkt <a 
href="#x1-120002.2.2">2.2.2<!--tex4ht:ref: clearing --></a>

     </p></li>
     <li 
  class="enumerate" id="x1-10007x3">Vor allem unterwegs kann man aus Gründen der Verkehrssicherheit sein
     Handy nicht immer benutzen, um die Satellitenbilder einzusehen.
     <!--l. 207--><p class="noindent" ><span 
class="cmsy-10">⇒ </span>Punkt <a 
href="#x1-130002.2.3">2.2.3<!--tex4ht:ref: pushpreview --></a></p></li></ol>
   <h5 class="subsubsectionHead"><span class="titlemark">2.2.1   </span> <a 
 id="x1-110002.2.1"></a>Reisemodus</h5>
<!--l. 213--><p class="noindent" >Um dem Benutzer keine Benachrichtungen zuzustellen, solange er sich schneller als
eine gewisse Geschwindigkeit bewegt (aktuell 25 km/h), ist es notwendig, serverseitig
zu erkennen, ob sich der Benutzer fortbewegt.
</p><!--l. 219--><p class="indent" >   Dazu gibt es verschiedene Möglichkeiten. Die einfachste besteht darin, die Daten
der IMU (<span 
class="ecti-1000">Intertial Measurement Unit</span>) des Smartphones auszulesen. Da diese
aber, besonders im geringen Geschwindigkeitsbereich, oft ungenau ist, wurde
entschieden, diesen zunächst nicht in die Berechnung der Benutzergeschwindigkeit
aufzunehmen.
</p><!--l. 228--><p class="indent" >   Eine zuverlässigere Aussage über die Geschwindgkeit des Benutzers lässt sich über
die letzten zwei GPS-Koordinaten und entsprechende Timestamps berechnen.
Um zu keinem Zeitpunkt mehr als eine Position pro Nutzer speichern zu
müssen (Datenschutz bzw. -sparsamkeit laut DSGVO) wird die aktuelle
Geschwindigkeit zum Zeitpunkt der Übermittlung des neuen Standorts neu
berechnet.
</p><!--l. 235--><p class="indent" >   Dazu wird die Luftlinie zwischen der alten und der neuen Koordinate auf der
Oberﬂäche einer Kugel berechnet und durch die Zeitdiﬀerenz der zwei Ortsangaben
geteilt. Es ergibt sich die Geschwindigkeit in km/h, welche mit in der Datenbank
gespeichert wird.
</p><!--l. 240--><p class="indent" >   Die Backend-Komponente, welche die Push-Benachrichtungen versendet, prüft bei
der nächsten Verarbeitung von Radardaten, ob der Wert unterhalb eines
besitmmten Grenzwerts (25 km/h) liegt. Zuvor wird noch ein Wert von der
gespeicherten Geschwindigkeit abgezogen, der von der seit dem letzten Update
verstrichenen Zeit und der zuvor berechneten Geschwindigkeit abhängt (sog.
<span 
class="ecti-1000">cool-oﬀ </span>-Funktion).
</p><!--l. 247--><p class="noindent" >
</p>
   <h5 class="subsubsectionHead"><span class="titlemark">2.2.2   </span> <a 
 id="x1-120002.2.2"></a>Aktualität von Benachrichtigungen</h5>
<!--l. 250--><p class="noindent" >Um das Usability-Problem der <span 
class="ecti-1000">veralteten Benachrichtigungen </span>zu beheben, wurden sog. <span 
class="ecti-1000">silent-</span>
bzw. <span 
class="ecti-1000">data pushes</span><span class="footnote-mark"><a 
href="html3.html#fn2x0"><sup class="textsuperscript">2</sup></a></span><a 
 id="x1-12001f2"></a>
implementiert.

</p><!--l. 256--><p class="indent" >   Diese werden vom Backend an ein Client-Gerät gesendet, sobald das Gewitter, für
das zuvor eine Push-Nachricht gesendet wurde, wieder abgezogen ist. Mittels
APNS<span class="footnote-mark"><a 
href="html4.html#fn3x0"><sup class="textsuperscript">3</sup></a></span><a 
 id="x1-12002f3"></a> bzw.
Google Firebase<span class="footnote-mark"><a 
href="html5.html#fn4x0"><sup class="textsuperscript">4</sup></a></span><a 
 id="x1-12003f4"></a>
wird auf dem Client-Gerät ein Teilprogramm ausgeführt, welches alle aktuell auf dem
Display angezeigten Benachrichtigungen löscht und eine Information darüber an das
Backend sendet.
</p>
   <div class="wrapfig-r"><a id="x1-120045"></a><img src="ios-lockscreen.png" alt="PIC"  />
<br />                 <div class="caption" 
><span class="id">Abbildung 5:                 </span><span  
class="content">Von
links: Push-Benachrichtigung im gesperrten
Zustand, Push-Benachrichtigung nach <span 
class="ecti-1000">force</span>
<span 
class="ecti-1000">touch</span></span></div><!--tex4ht:label?: x1-120045 -->                                              </div>
<!--l. 274--><p class="indent" >   Die Information darüber, ob es aufgehört hat zu regnen, wird dem aktuellen
Radarbild alle 5 Minuten entnommen.
</p>
   <h5 class="subsubsectionHead"><span class="titlemark">2.2.3   </span> <a 
 id="x1-130002.2.3"></a>Generierung von Vorschaubildern</h5>
<!--l. 280--><p class="noindent" >Um die mit dem Smartphone notwendige Interaktion gering zu halten, wurden in der
iOS App sog. <span 
class="ecti-1000">Media Attachments </span>implementiert. So ist es möglich, neben einer
sonst rein textuellen Benachrichtigung auch Bilder (u.a.) auf dem Display
anzuzeigen.
</p><!--l. 287--><p class="indent" >   Auf modernen iOS-Geräten (iPhone 6S und aufwärts) besteht
zudem die Möglichkeit auch im gesperrten Zustand durch die sog. <span 
class="ecti-1000">force</span>
<span 
class="ecti-1000">touch</span>-Geste<span class="footnote-mark"><a 
href="html6.html#fn5x0"><sup class="textsuperscript">5</sup></a></span><a 
 id="x1-13001f5"></a>
einen bildschirmfüllende Kartenausschnitt anzuzeigen.
</p><!--l. 293--><p class="indent" >

</p>
   <h4 class="subsectionHead"><span class="titlemark">2.3   </span> <a 
 id="x1-140002.3"></a>Backend</h4>
<!--l. 297--><p class="noindent" >Neben der zuvor beschriebenen Wetterdaten- und Push-Komponente
(zusammengefasst zum <span 
class="ecti-1000">dwd</span>-Container) verwaltet der <span 
class="ecti-1000">app</span>-Container alle
Interaktionen mit Endgeräten. Zur persistenten Speicherung und als Interface
zur Push-Komponente dient eine Instanz der <span 
class="ecti-1000">Key-Value-Store</span>-Datenbank
&#x0022;MongoDB&#x0022;.
</p>

   <h5 class="subsubsectionHead"><span class="titlemark">2.3.1   </span> <a 
 id="x1-150002.3.1"></a>Öﬀentliche REST API</h5>
<!--l. 310--><p class="noindent" >Die von den Endgeräten initierte Kommunikation mit dem Backend wird über eine
REST-basierte HTTP API abgehandelt.
</p><!--l. 315--><p class="indent" >   Endgeräte identiﬁzieren sich gegenüber dem Server anhand eines Tokens. Dieses
Token generiert das Betriebssystem beim ersten Start der App. Es dient gleichzeitig
der Identiﬁzierung gegenüber der API für Push-Benachrichtigungen von Apple bzw.
Google.
</p><!--l. 320--><p class="indent" >   Das Token ist insofern nicht sicherheitsrelevant, als dass anhand des Tokens keine
Informationen über das Gerät, den Nutzer oder seinen Standort abgefragt werden
können.
</p><!--l. 332--><p class="indent" >   Um den schreibenden Zugang zur Datenbank auf eﬀektive Weise zu schützen muss
zunächst ein Konzept von <span 
class="ecti-1000">Nutzern </span>bzw. <span 
class="ecti-1000">Accounts </span>eingeführt werden. Ein Account
muss veriﬁziert werden (z.B. Captcha, Telefonnummer, E-Mail, ...), bevor es ihm
möglich ist, Standortdaten an das Backend zu übermitteln.
</p><!--l. 338--><p class="noindent" >
</p>
   <h5 class="subsubsectionHead"><span class="titlemark">2.3.2   </span> <a 
 id="x1-160002.3.2"></a>Verarbeitung von Blitz-Daten</h5>
<!--l. 340--><p class="noindent" >
</p>
   <h4 class="subsectionHead"><span class="titlemark">2.4   </span> <a 
 id="x1-170002.4"></a>Tileserver</h4>
<!--l. 342--><p class="noindent" >Um die in Kapitel <a 
href="#x1-70002.1.1">2.1.1<!--tex4ht:ref: visual --></a> generierten mbtiles-Archivdateien über eine einheitliche API
anzubieten kommt ein sog. <span 
class="ecbx-1000">Tileserver </span>zum einsatz. Gebräuchliche Schnittstellen wie
WTMS (XML-basiert) und GeoJSON (JavaScript Object Notation) ermöglichen es
Kartenmaterial kachelbasiert abrufen zu können.
</p><!--l. 350--><p class="indent" >   Es existieren verschiedene freie Tileserver-Implementierungen. Sie unterscheiden
sich hauptsächlich im Technologie-Stack, auf dem sie basieren. meteocool
verwendet hierzu die in Node.js implementierte Software <span 
class="ectt-1000">tileserver-gl</span>, da die
Schnittstelle zum in <span 
class="ecbx-1000">??</span> beschriebenen <span 
class="ecti-1000">dwd</span>-Container am einfachen realisierbar
war.

</p><!--l. 356--><p class="noindent" >
</p>
   <h4 class="subsectionHead"><span class="titlemark">2.5   </span> <a 
 id="x1-180002.5"></a>Frontend</h4>
<!--l. 358--><p class="noindent" >Die plattformübergreifende, HTML5-basierte Web-Oberﬂäche basiert auf dem
Mapping-Framework <span 
class="ecti-1000">OpenLayers</span>. OpenLayers ist ein in JavaScript geschriebenes
Framework, um Kartenmaterial ﬂexibel und über diverse Anbindungen (Backends)
im Browser darzustellen. Eine der wichtigsten Abstraktionen von OpenLayers besteht
in der Übereinanderlagerung von sog. Layern. So ist es z.B. mit geringem Aufwand
möglich, mehrere Layer aus verschiedenen Quellen geographisch korrekt
übereinanderzulegen und mit ihnen zu interagieren.
</p><!--l. 367--><p class="indent" >   Auf ein komplexes GUI-Framework (Angular, Vue, etc.) wurde verzichtet, da die
App fast ausschließlich aus der Kartenansicht besteht.
</p><!--l. 372--><p class="indent" >   Zur Interaktion mit dem Backend baut der Browser nach dem Aufruf der
meteocool-Startseite eine WebSockets-Verbindung zum Backend hin auf. Über diese
Verbindung werden asynchron durch das Backend ausgelöste Informationen an die
Clients übertragen, u.a.:
</p>
     <ul class="itemize1">
     <li class="itemize">Aktualisierte Radardaten stehen zur Verfügung: Client lädt Wolken-Layer
     erneut,
     </li>
     <li class="itemize">Blitz-Event (Koordinaten und Intensität): Client zeigt visuellen Marker
     auf Karte an,
     </li>
     <li class="itemize">Push-Benachrichtigung<span class="footnote-mark"><a 
href="html7.html#fn6x0"><sup class="textsuperscript">6</sup></a></span><a 
 id="x1-18001f6"></a>
     triﬀt ein: Client zeigt Benachrichtigung über <span 
class="ecti-1000">Javascript Desktop Notiﬁcation</span>
     <span 
class="ecti-1000">API</span>.</li></ul>
<!--l. 391--><p class="indent" >   Desweiteren verwendet die Oberﬂäche die <span 
class="ecti-1000">Google Workbox </span>Bibliothek, um
meteocool so zu einer sogenannten <span 
class="ecbx-1000">Progressive Web App </span>(PWA) zu machen.
Durch die Verwendung von modernen Webtechnologien wie <span 
class="ecti-1000">Service Workers </span>und
<span 
class="ecti-1000">Local Storage </span>wird auf diese Weise die Geschwindigkeit sowie die Resilienz gegenüber
(kurzzeitigen) Ausfällen der Netzwerkverbindung erhöht und die Verwendung von
mobilen Daten reduziert.
</p>
   <h4 class="subsectionHead"><span class="titlemark">2.6   </span> <a 
 id="x1-190002.6"></a>Frontend</h4>

<!--l. 3--><p class="noindent" >Die plattformübergreifende, HTML5-basierte Web-Oberﬂäche basiert auf dem
Mapping-Framework <span 
class="ecti-1000">OpenLayers</span>. OpenLayers ist ein in JavaScript geschriebenes
Framework, um Kartenmaterial ﬂexibel und über diverse Anbindungen (Backends)
im Browser darzustellen. Eine der wichtigsten Abstraktionen von OpenLayers besteht
in der Übereinanderlagerung von sog. Layern. So ist es z.B. mit geringem Aufwand
möglich, mehrere Layer aus verschiedenen Quellen geographisch korrekt
übereinanderzulegen und mit ihnen zu interagieren.
</p><!--l. 12--><p class="indent" >   Auf ein komplexes GUI-Framework (Angular, Vue, etc.) wurde verzichtet, da die
App fast ausschließlich aus der Kartenansicht besteht.
</p><!--l. 17--><p class="indent" >   Zur Interaktion mit dem Backend baut der Browser nach dem Aufruf der
meteocool-Startseite eine WebSockets-Verbindung zum Backend hin auf. Über diese
Verbindung werden asynchron durch das Backend ausgelöste Informationen an die
Clients übertragen, u.a.:
</p>
     <ul class="itemize1">
     <li class="itemize">Aktualisierte Radardaten stehen zur Verfügung: Client lädt Wolken-Layer
     erneut,
     </li>
     <li class="itemize">Blitz-Event (Koordinaten und Intensität): Client zeigt visuellen Marker
     auf Karte an,
     </li>
     <li class="itemize">Push-Benachrichtigung<span class="footnote-mark"><a 
href="html8.html#fn7x0"><sup class="textsuperscript">7</sup></a></span><a 
 id="x1-19001f7"></a>
     triﬀt ein: Client zeigt Benachrichtigung über <span 
class="ecti-1000">Javascript Desktop Notiﬁcation</span>
     <span 
class="ecti-1000">API</span>.</li></ul>
<!--l. 36--><p class="indent" >   Desweiteren verwendet die Oberﬂäche die <span 
class="ecti-1000">Google Workbox </span>Bibliothek, um
meteocool so zu einer sogenannten <span 
class="ecbx-1000">Progressive Web App </span>(PWA) zu machen.
Durch die Verwendung von modernen Webtechnologien wie <span 
class="ecti-1000">Service Workers </span>und
<span 
class="ecti-1000">Local Storage </span>wird auf diese Weise die Geschwindigkeit sowie die Resilienz gegenüber
(kurzzeitigen) Ausfällen der Netzwerkverbindung erhöht und die Verwendung von
mobilen Daten reduziert.
</p><!--l. 44--><p class="noindent" >
</p>
   <h3 class="sectionHead"><span class="titlemark">3   </span> <a 
 id="x1-200003"></a>Mobile Anwendungen</h3>
<!--l. 46--><p class="noindent" >Durch die beschriebenen Optimierungen an der HTML5-Oberﬂäche kann sie nun als
Grundlage für eine “native” Anwendung verwendet werden.

</p><!--l. 50--><p class="indent" >   Für die zwei populärsten mobilen Betriebssysteme, iOS und Android, wurde
jeweils eine App entwickelt. Dies ist notwendig, um nativ vom Betriebssytem
bereitgestellte Schnittstellen wie <span 
class="ecti-1000">Background Location </span>und <span 
class="ecti-1000">Push-Benachrichtigungen</span>
nutzen zu können. Für reine Web-Apps stehen diese Funktionalitäten nicht zur
Verfügung.
</p>

    </div>
  </body>
</html>
<!-- vim: set ts=2 sw=2 expandtab: -->
